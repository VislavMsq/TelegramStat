package org.stb.service.impl;import lombok.RequiredArgsConstructor;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import org.stb.bot.TGBot;import org.stb.entity.*;import org.stb.entity.specDto.PollChannelDtoWrapper;import org.stb.exception.ErrorMessage;import org.stb.repository.*;import org.stb.service.PollingService;import org.stb.util.Util;import org.stb.entity.*;import org.stb.entity.enums.InteractionType;import org.stb.entity.specDto.PollChannelDto;import org.stb.exception.PollExistsException;import org.stb.repository.*;import org.stb.service.CallBackService;import org.stb.service.MessageService;import org.telegram.telegrambots.meta.api.methods.send.SendMessage;import org.telegram.telegrambots.meta.api.objects.CallbackQuery;import org.telegram.telegrambots.meta.api.objects.Update;import org.telegram.telegrambots.meta.api.objects.replykeyboard.InlineKeyboardMarkup;import org.telegram.telegrambots.meta.api.objects.replykeyboard.buttons.InlineKeyboardButton;import org.telegram.telegrambots.meta.exceptions.TelegramApiException;import java.time.LocalDateTime;import java.util.*;import java.util.stream.Collectors;import static org.stb.util.Util.delete;import static org.stb.util.Util.toMessage;@Service@RequiredArgsConstructorpublic class CallBackServiceImpl implements CallBackService {    private final PollRawRepository pollRawRepository;    private final PollRepository pollRepository;    private final ButtonRepository buttonRepository;    private final UserRepository userRepository;    private final ButtonUserLinkRepository buttonUserLinkRepository;    private final ChannelRepository channelRepository;    private final AdminRepository adminRepository;    private final PollingService pollingService;    private final MessageService messageService;    private static final Map<List<UUID>, PollChannelDtoWrapper> callbackMap = new HashMap<>();    @Transactional    @Override    public void proceedCallBack(CallbackQuery callbackQuery, TGBot bot) throws TelegramApiException {        String[] ss = callbackQuery.getData().split(" ");        if (ss[0].equals("cancel")) {            Util.delete(callbackQuery.getMessage().getChatId(), callbackQuery.getMessage().getMessageId(), bot);        } else if (ss[0].equals("choicepoll")) {            UUID uuid = UUID.fromString(ss[1]);            for (List<UUID> uuidList : callbackMap.keySet()) {                if (uuidList.contains(uuid)) {                    PollChannelDtoWrapper dtoWrapper = callbackMap.get(uuidList);                    List<PollChannelDto> dtoList = dtoWrapper.getWrapper();                    Optional<PollChannelDto> optionalChannelDto = dtoList.stream()                            .filter(s -> s.getCallBackId().equals(uuid))                            .findFirst();                    if (optionalChannelDto.isEmpty()) {                        bot.execute(Util.toMessage(callbackQuery.getFrom().getId(), "Помилка"));                        Util.delete(callbackQuery.getMessage().getChatId(), callbackQuery.getMessage().getMessageId(), bot);                        return;                    }                    PollChannelDto pollChannelDto = optionalChannelDto.get();                    PollRaw pollRaw = pollRawRepository.findFirstById(dtoWrapper.getPollId());                    Poll poll;                    try {                        poll = proceedPoll(pollRaw, pollChannelDto.getChannelId());                    } catch (PollExistsException e) {                        bot.execute(Util.toMessage(callbackQuery.getFrom().getId(), "Таке опитування вже існує"));                        Util.delete(callbackQuery.getMessage().getChatId(), callbackQuery.getMessage().getMessageId(), bot);                        return;                    }                    pollingService.pollingConstructor(poll, bot);                    Util.delete(callbackQuery.getMessage().getChatId(), callbackQuery.getMessage().getMessageId(), bot);                    return;                }            }        } else if (ss[0].equals("vote")) {            Button button = buttonRepository.findFirstById(UUID.fromString(ss[1]));            ButtonUserLink buttonUserLink = new ButtonUserLink();            buttonUserLink.setButton(button);            Channel channel = button.getPoll().getChannel();            List<Button> buttonList = button.getPoll().getButtons();            // потрібено перевірити кожну кнопку в массиві buttonList та перевірити їх на співпадіння з користувачем в            // buttonUserLinkRepository і якщо є хочаб одне співпадіняя то прервати операцію,            // пропонує не робити це за допомогою ітератора а зробити іншим способом що не буде навантажувати базу даних            // та не буде викликати зайві запити до бази даних            User user;            if (userRepository.existsByChannelAndTelegramId(channel, callbackQuery.getFrom().getId())) {                user = userRepository.findFirstByTelegramId(callbackQuery.getFrom().getId());                List<Button> userButtons = buttonUserLinkRepository.findAllByUser(user).stream()                        .map(ButtonUserLink::getButton)                        .collect(Collectors.toList());                user.setLastMessageTime(LocalDateTime.now());                for (Button b : buttonList) {                    if (userButtons.contains(b)) {                        bot.execute(Util.toMessage(user.getTelegramId(), "ви вже голосували"));                        return;                    }                }                buttonUserLink.setUser(user);            } else {                user = new User();                user.setChannel(channel);                user.setTelegramId(callbackQuery.getFrom().getId());                userRepository.save(user);                buttonUserLink.setUser(user);                user.setLastMessageTime(LocalDateTime.now());            }            buttonUserLink.setButton(button);            bot.execute(Util.toMessage(user.getTelegramId(), "Дякуємо за ваш голос!"));            messageService.proceedMessage(channel, null, callbackQuery.getMessage(), user, InteractionType.CLICK);            buttonUserLinkRepository.save(buttonUserLink);        }    }    @Override    @Transactional    public SendMessage createCallBack(Update update) {        String[] ss = update.getMessage().getText().split(" ");        if (ss.length != 2) {            Util.toMessage(update.getMessage().getFrom().getId(), "Недостатньо аргументів");        }        Long id = update.getMessage().getFrom().getId();        List<Admin> admins = adminRepository.findAllByTelegramId(id);        List<Channel> channels = admins.stream()                .map(Admin::getChannel)                .collect(Collectors.toList());        return createButtons(channels, UUID.fromString(ss[1]), update);    }    @Override    public SendMessage createButtons(List<Channel> channels, UUID id, Update update) {        InlineKeyboardMarkup markupInline = new InlineKeyboardMarkup();        List<List<InlineKeyboardButton>> rowsInline = new ArrayList<>();        List<InlineKeyboardButton> rowInline = new ArrayList<>();        InlineKeyboardButton action = new InlineKeyboardButton();        action.setText("Відміна");        action.setCallbackData("cancel");        rowInline.add(action);        rowsInline.add(rowInline);        List<UUID> uuids = new ArrayList<>();        List<PollChannelDto> pollChannelDtos = new ArrayList<>();        for (Channel channel : channels) {            rowInline = new ArrayList<>();            action = new InlineKeyboardButton();            action.setText(channel.getTitle());            UUID uuid = UUID.randomUUID();            PollChannelDto pollChannelDto = new PollChannelDto();            pollChannelDto.setCallBackId(uuid);            pollChannelDto.setChannelId(channel.getId());            pollChannelDtos.add(pollChannelDto);            action.setCallbackData("choicepoll " + uuid);            uuids.add(uuid);            rowInline.add(action);            rowsInline.add(rowInline);        }        markupInline.setKeyboard(rowsInline);        PollChannelDtoWrapper dtoWrapper = new PollChannelDtoWrapper();        dtoWrapper.setWrapper(pollChannelDtos);        dtoWrapper.setPollId(id);        callbackMap.put(uuids, dtoWrapper);        SendMessage message = Util.toMessage(update.getMessage().getFrom().getId(), "Оберіть канал");        message.setReplyMarkup(markupInline);        return message;    }    private Poll proceedPoll(PollRaw pollRaw, UUID channelId) throws PollExistsException {        Channel channel = channelRepository.findFirstById(channelId);        if (pollRepository.existsByTextAndChannel(pollRaw.getText(), channel)) {            throw new PollExistsException(ErrorMessage.POLL_EXISTS);        }        Poll poll = new Poll();        poll.setCreatedAt(LocalDateTime.now());        poll.setText(pollRaw.getText());        poll.setChannel(channel);        pollRepository.save(poll);        List<Button> buttons = new ArrayList<>();        for (            ButtonRaw buttonRaw : pollRaw.getButtons()) {            Button button = new Button();            button.setText(buttonRaw.getText());            button.setPoll(poll);            button.setCallbackData("vote " + button.getId());            button.setCreatedAt(LocalDateTime.now());            buttonRepository.save(button);            button.setCallbackData("vote " + button.getId());            buttons.add(button);        }        poll.setButtons(buttons);        return poll;    }}